<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我爱学习</title>
  
  <subtitle>我爱Java我自豪</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bujianyouchou.net/"/>
  <updated>2018-03-09T08:59:40.245Z</updated>
  <id>http://bujianyouchou.net/</id>
  
  <author>
    <name>不见忧愁俊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例模式</title>
    <link href="http://bujianyouchou.net/2018/03/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bujianyouchou.net/2018/03/12/单例模式/</id>
    <published>2018-03-12T04:02:41.856Z</published>
    <updated>2018-03-09T08:59:40.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h1><p>单例模式有最基本的<u>饿汉</u>与<u>懒汉</u>模式，之后为了弥补线程安全及效率问题引进了<u>双重检查加锁</u>模式；</p><p>更进阶的，可以使用<u>内部静态类</u>的模式来延迟加载；</p><p>最后还有个简单且无法通过反射来获取多个实例的实现方式：<u>枚举类</u><br><a id="more"></a></p><h2 id="饿汉单例"><a href="#饿汉单例" class="headerlink" title="饿汉单例"></a>饿汉单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，类加载的时候就已经创建了Singleton静态实例，说明很“饥饿”。<br>这种方式效率高（线程安全），但是没有延迟加载（一直占用空间）。</p><h2 id="懒汉式–线程安全"><a href="#懒汉式–线程安全" class="headerlink" title="懒汉式–线程安全"></a>懒汉式–线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">      s = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式安全，达到延迟的目的，但效率太低（为了线程安全，整个方法都加了锁）。</p><h2 id="双重检查加锁"><a href="#双重检查加锁" class="headerlink" title="双重检查加锁"></a>双重检查加锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton s;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>（Singleton.class）&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)&#123;</span><br><span class="line">          s = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方面都满足要求（只有第一次创建实例的时候会加锁），java 1.5 后volatile关键字能够禁止代码重排序。<br>===&gt;ps:为何要加volatile<br>假设没有关键字volatile的情况下，两个线程A、B，都是第一次调用该单例方法，线程A先执行instance = new Instance()，该构造方法是一个非原子操作，编译后生成多条字节码指令，由于JAVA的指令重排序，可能会先执行instance的赋值操作，该操作实际只是在内存中开辟一片存储对象的区域后直接返回内存的引用，之后instance便不为空了，但是实际的初始化操作却还没有执行，如果就在此时线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的Instance对象，所以需要加入volatile关键字，禁止指令重排序优化，从而安全的实现单例。</p><h2 id="内部静态类，Initialization-On-Demand-Holder-idiom"><a href="#内部静态类，Initialization-On-Demand-Holder-idiom" class="headerlink" title="内部静态类，Initialization On Demand Holder idiom"></a>内部静态类，Initialization On Demand Holder idiom</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletionHolder</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式能保证单例的线程安全的原因：<br>①静态内部类只有第一次使用才会加载，保证了延迟性；<br>②因为静态内部类初始化的时候是通过JVM保证线程安全的，所以有线程安全的天然优势。</p><h2 id="使用枚举（推荐）"><a href="#使用枚举（推荐）" class="headerlink" title="使用枚举（推荐）"></a>使用枚举（推荐）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">     INSTANCE;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"I am writing!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton s = Singleton.INSTANCE;</span><br></pre></td></tr></table></figure><p>为什么推荐这种呢？因为简单！而且这种方式无法通过反射获取单例类。</p><p>P.S.<br>方法1到4都可以通过反射获取新的单例,如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Singleton&gt; clz = Singleton.class;</span><br><span class="line">Constructor&lt;Singleton&gt; con == clz.getDeclaredConstructor(<span class="keyword">new</span> Class[] &#123;&#125;);</span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Singleton s3 = con.newInstance(<span class="keyword">new</span> Object[] &#123;&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单例模式的实现&quot;&gt;&lt;a href=&quot;#单例模式的实现&quot; class=&quot;headerlink&quot; title=&quot;单例模式的实现&quot;&gt;&lt;/a&gt;单例模式的实现&lt;/h1&gt;&lt;p&gt;单例模式有最基本的&lt;u&gt;饿汉&lt;/u&gt;与&lt;u&gt;懒汉&lt;/u&gt;模式，之后为了弥补线程安全及效率问题引进了&lt;u&gt;双重检查加锁&lt;/u&gt;模式；&lt;/p&gt;
&lt;p&gt;更进阶的，可以使用&lt;u&gt;内部静态类&lt;/u&gt;的模式来延迟加载；&lt;/p&gt;
&lt;p&gt;最后还有个简单且无法通过反射来获取多个实例的实现方式：&lt;u&gt;枚举类&lt;/u&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://bujianyouchou.net/categories/Java/"/>
    
    
      <category term="设计模式" scheme="http://bujianyouchou.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="http://bujianyouchou.net/2018/03/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>http://bujianyouchou.net/2018/03/01/我的第一篇文章/</id>
    <published>2018-03-01T10:22:59.000Z</published>
    <updated>2018-03-01T10:22:59.085Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
